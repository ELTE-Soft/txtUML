grammar hu.elte.txtuml.xd.XDiagramDefinition with org.eclipse.xtext.xbase.Xbase
generate xDiagramDefinition "http://www.elte.hu/txtuml/xd/XDiagramDefinition"

import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types

Model:
	(package = PackageDeclaration)?
	(imports = XImportSection)?
	signature = DiagramSignature '{' (instructions += Instruction)* '}'
;

// environment

PackageDeclaration:
    'package' name=QualifiedName ';'
;

// diagram instructions

DiagramSignature :
	// generic types
	diagramType = "state-machine-diagram" name=ID "for" genArg=[types::JvmGenericType|QualifiedName] |
	// non-generic types
	diagramType = "class-diagram" name=ID
;

BinaryIdentifierInstruction:
	val = WrappedTypeExpression 
	op = ("left-of" | "right-of" | "above" | "below") 
	of = WrappedTypeExpression
;

BinaryListInstruction:
	val = WrappedTypeExpressionList
	(linkEnd = ("start" | "end"))?
	op = ("east-of" | "west-of" | "north-of" | "south-of")
	of = WrappedTypeExpressionList
;

PhantomInstruction:
	op = ("phantom")
	name=ID
;

UnaryListInstruction:
	op = ("topmost" | "leftmost" | "rightmost" | "bottommost" | "row" | "column" | "show") 
	val = WrappedTypeExpressionList
;

GroupInstruction:
	op = ("group") 
	name=ID 
	val = WrappedTypeExpressionList
	(align = ("top-to-bottom" | "bottom-to-top" | "left-to-right" | "right-to-left"))?
;

UnaryNumberInstruction:
	op = ("spacing") 
	val = WrappedNumericExpression
;

DiamondInstruction:
	op = "diamond" args = WrappedArgumentExpressionList
;

PriorityInstruction:
	op = "priority" prior = WrappedIntegralExpression "for" val = WrappedTypeExpressionList
;

Instruction:
	(
		BinaryIdentifierInstruction |
		BinaryListInstruction |
		PhantomInstruction |
		UnaryListInstruction |
		GroupInstruction |
		UnaryNumberInstruction |
		DiamondInstruction |
		PriorityInstruction
	)
	";"
;

// Argument & list types

WrappedTypeExpressionList : 
	wrapped = TypeExpressionList | '{' wrapped = TypeExpressionList '}'
;

TypeExpressionList :
	expressions += TypeExpression (',' expressions += TypeExpression)*
;

WrappedTypeExpression : 
	wrapped = TypeExpression | '{' wrapped = TypeExpression '}'
;

TypeExpression :
	phantom="phantom" | 
	name=[types::JvmGenericType|QualifiedName]
;

WrappedArgumentExpressionList : 
	wrapped = ArgumentExpressionList | '{' wrapped = ArgumentExpressionList '}'
;

ArgumentExpressionList: 
	expressions += ArgumentExpression (',' expressions += ArgumentExpression)*
;

ArgumentExpression: 
	argName = ID ':' expression = TypeExpression | 
	expression = TypeExpression
;

WrappedNumericExpression : wrapped = NumericExpression | '{' wrapped = NumericExpression '}';

NumericExpression :
	Number'%'?
;

WrappedIntegralExpression : wrapped = IntegralExpression | '{' wrapped = IntegralExpression '}';

IntegralExpression :
	INT'%'?
;
