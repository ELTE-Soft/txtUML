package pingpong.x.^model;

// Classes

class TopClass {

	/**
	 * Creates an instance of ping and pong and connects them. If gets a pong
	 * signal, sends it to the ping instance.
	 */
	public TopClass() {
		PingClass ping = create(PingClass);
		PongClass pong = create(PongClass);

		link(TopClass_PingClass.top, this, TopClass_PingClass.ping, ping);
		link(TopClass_PongClass.top, this, TopClass_PongClass.pong, pong);

		connect(Ping_Pong_Connector.pingEnd, ping->(PingClass.PingPort), Ping_Pong_Connector.pongEnd,
				pong->(PongClass.PongPort));

		start(ping);
		start(pong);
	}

	behavior port TopPort {
		required PingInterface;
		provided PongInterface;
	}

	initial Init;
	state Waiting;

	transition Initialize {
		from Init;
		to Waiting;
	}

	transition AcceptPong {
		from Waiting;
		to Waiting;
		trigger PongSignal;
		effect {
			send sigdata to this->(TopClass_PingClass.ping).selectAny();
		}
	}

}

class PingClass {

	behavior port PingPort {
		required PongInterface;
		provided PingInterface;
	}

	initial Init;
	state Waiting;

	transition Initialize {
		from Init;
		to Waiting;
	}

	transition AcceptPong {
		from Waiting;
		to Waiting;
		trigger PongSignal;
		effect {
			if (sigdata.count > 0) {
				send new PingSignal(sigdata.count - 1) to this->(PingPort);
				log("ping");
			}
		}
	}

}

class PongClass {

	/**
	 * Creates an instance of inner pong and through a delegation connector,
	 * connects its port to the port of that instance.
	 */
	public PongClass() {
		InnerPongClass inner = create(InnerPongClass);

		link(PongClass_InnerPongClass.pong, this, PongClass_InnerPongClass.inner, inner);
		connect(this->(PongPort), Pong_InnerPong_Connector.innerEnd, inner->(InnerPongClass.PongPort));
		start(inner);
	}

	port PongPort {
		required PingInterface;
		provided PongInterface;
	}

}

class InnerPongClass {

	behavior port PongPort {
		required PingInterface;
		provided PongInterface;
	}

	initial Init;
	state Waiting;

	transition Initialize {
		from Init;
		to Waiting;
	}

	transition AcceptPing {
		from Waiting;
		to Waiting;
		trigger PingSignal;
		effect {
			if (sigdata.count > 0) {
				send new PongSignal(sigdata.count - 1) to this->(PongPort);
				log("pong");
			}
		}
	}

}

// Signals and interfaces

signal PingSignal {
	public int count;
}

signal PongSignal {
	public int count;
}

interface PingInterface {
	reception PingSignal;
}

interface PongInterface {
	reception PongSignal;
}

// Associations

composition PongClass_InnerPongClass {
	hidden container PongClass pong;
	1 InnerPongClass inner;
}

composition TopClass_PingClass {
	hidden container TopClass top;
	1 PingClass ping;
}

composition TopClass_PongClass {
	hidden container TopClass top;
	1 PongClass pong;
}

// Connectors

connector Ping_Pong_Connector { // assembly connector
	TopClass_PingClass.ping->PingClass.PingPort pingEnd;
	TopClass_PongClass.pong->PongClass.PongPort pongEnd;
}

delegation Pong_InnerPong_Connector { // delegation connector
	PongClass_InnerPongClass.pong->PongClass.PongPort pongEnd;
	PongClass_InnerPongClass.inner->InnerPongClass.PongPort innerEnd;
}
